.tfvars:
========
two types:
1. .tfvars: ex: dev.tfvars
2. .auto.tfvars



* passing multiple tfvars
if there are two .tfvars
x.tfvars: 100
y.tfvars> 200 , it will override with second value


The state file is updated only when Terraform runs and refreshes or applies changes based on the cloud provider’s actual state.
drift detection:
================
manually delete old resource (t3.small) and recreate a resource with t3.micro
The resource in the state (i-12345) does not exist in the cloud → marked as to be created

The manually created resource (i-67890) is unknown to Terraform → also will be created if you reapply your config

Terraform will not automatically know that the manual t3.small instance is “the same” as your resource in code
Manual deletion + creation = drift

Terraform detects drift when state vs cloud mismatch

Terraform cannot automatically assume your manual t3.small is the same resource → you must import it or Terraform will try to recreate it

1. during terraform apply:
creates both state file and cloud vendor(aws) through provider
2. changes in terraform configuration code:
terraform apply,
terraform checks in state file
Query to cloud provider(what to exists , what needs to update)
first chnages are made in cloud vendor then changes are made in state file

[Terraform config] + [State file] + [Cloud provider]
        ↓ plan/apply
Cloud provider updated → Terraform confirms success → State file updated


s3 bucket:
==========
Terraform applies resources → updates in-memory state (and temporary local file) →
on successful completion → final state written to S3.
splat expressions:
===================
variable "ports"{
default = {
ssh=22
nginx=80
node=8080
}
}

how to loop?
output "list"{
value=[for x,y in var.ports : y]
}

here x is a key and y is a value

ex:2
====
variable "dummy"{
default = {
apple = {
  price = 100
}
banana={
price=100
}
citrus={
price=100
}
}
}

output "dummy"{
value = {for x,y in var.dummy : x => y.price}
}
here x is a key and y is a value


.tfvars
state file
s3 bucket
dynamodb
splat expression
locals
terraform conditions


terraform plan -var create_ec2=true



========================================================================================
to provide values dynamically according to the requirement so
1.create a folder
2. inside a folder create a two files dev.tfvars , prod.tfvars and main.tfvars

main.tf
===========
variable "env"{}
output "env"{
value=var.env
}

dev.tfvars:
===========
env="dev"

prod.tfvars:
============
env="prod"

terraform init
terraform apply -var-file=dev.tfvars


variables-3:
============
create  two folders dev and prod
dev
--
main.tf
dev.auto.tfvars

prod
----
main.tf:  same as above
prod.auto.tfvars


terraform init
terraform apply -auto-approve, here auto variable values are detected

how to read more than one .tfvars file ?
terraform apply -var-file=env-dev/dev.tfvars  -var-file=env-prod/prod.tfvars
if there are multiple .tfvars its difficult to write everything then we should go .auto.tfvars

Passing multiple tfvars:
========================
terraform apply -var-file=dev.tfvars  - var-file=prod.tfvars , here if there are multiple .tfvars with same variable names like
dev.tfvars : env="dev"
prod.tfvars : env="prod"
then last env value overrides dev with prod
here order is important ----> latest overrides new

autoloaded .auto.tfvars
-----------------------
terraform.tfvars
dev.auto.tfvars
prod.auto.tfvars
terraform apply, then it will load automatically


state:
======
create a state folder
create a file main.tf
main.tf
========
terraform {
  backend "s3" {
    bucket = "mybucket"
    key    = "sample/terraform.tfstate"
    region = "us-east-1"
  }
}

output "test"{
value="Hello"
}


S3 backend = store Terraform state file as a file in S3
DynamoDB = optional locking mechanism
Terraform does not store state in a database

dynamodb:
=========
* suppose if we open cd /etc/passwd in one server , to open same path in another server we will get an error like already same path is in open
terraform.tfstate file if one of the team member can able to do changes ,but multiple team members open and edit at a time , there conflicts will come , who edit or delete
use_lockfile = true enables local concurrency protection.
Running terraform init creates .terraform.lock.hcl to lock provider versions.
Terraform automatically updates this lock file only if provider versions change; otherwise it remains unchanged.